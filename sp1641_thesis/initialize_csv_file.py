import networkx as nx
import numpy as np
import pandas as pd
import networkx
import matplotlib.pyplot as plt

from scipy.sparse import csr_matrix
import re
import os

class DataStorage:

    def __init__(self):
        self.file_path = "simulation_data.csv"

        if not os.path.exists(self.file_path):
            self.__initialize_a_csv_file()

        self.existing_df = pd.read_csv(self.file_path)

        self.columns_names = np.array(["Initial Adjacency Matrix", "Braess Adjacency Matrix", "Amount of Traffic", "Initial Average Travel Time", "Braess Average Travel Time",
                                       "Graph Spectrum", "All Average Travel Time", "Number of Nodes"])


    def __initialize_a_csv_file(self):
        initial_data = {"Initial Adjacency Matrix": [], "Braess Adjacency Matrix": [],
                        "Amount of Traffic": [], "Initial Average Travel Time": [], "Braess Average Travel Time": [],
                        "Graph Spectrum": [], "All Average Travel Time": [], "Number of Nodes":[]}

        df = pd.DataFrame(initial_data)
        df.to_csv("simulation_data.csv", mode='a', index=False, header=True)

    def add_data(self, new_data: dict) -> None:
        new_df = pd.DataFrame(new_data)
        update_df = self.existing_df.append(new_df, ignore_index=False)
        update_df.to_csv(self.file_path, index=False)

    #This is used later to retrieve out for machine learning
    def retrieve_data(self):
        df1 = pd.read_csv(self.file_path)

        A = df1["Initial Adjacency Matrix"]
        data_str = A[0]
        self.testing_if_data_stored_correctly(df1)

    #Functions to translate graphs to storable data structure.
    def create_dict_representation(self, G:networkx.classes.digraph.DiGraph) -> dict:
        dict_representation = {}
        for i in G.edges():
            dict_representation[i] = G[i[0]][i[1]]['weight']
        return dict_representation

    def return_graph_from_dict_representation(self, G_dict):
        G = nx.DiGraph()
        for i in G_dict:
            G.add_edge(i[0], i[1], weight = G_dict(i))

        nx.draw(G)
        plt.show()
        breakpoint()


    #This function made to provide reference of how data is stored in the csv file.
    def help_(self)->None:
        #Reference for developer
        #Below are columns.
        # initial_data = {
        # "Initial Adjacency Matrix": {edge->tuple:weight->int)}
        # "Braess Adjacency Matirx": {edge->tuple:weight->int)},
        # "Amount of traffic": Int
        # "Initial Average Travel Time": Float,
        # "Braess Average Travel Time": Float,
        # "Graph Specturm": np.array([{edge->tuple:weight->int)}, {edge->tuple:weight->int)}]),
        # "All Average Travel Time": list->int,
        # "Number of Nodes": Int
        # }

        print("""
        Below is the description of how the data is stored in the csv file.
        
        It was aimed to store less data as possible for the machine learning model without
        loosing the important part of it. 
        
        Data generated by the simulation is stored with option of user. 
        
        The CSV file has 7 headers with it
        
        Initial Adjacency Matrix
        ------The graph before the braess paradox occurred. 
        -----(The graph is store as a dictionary, Dict->{(edge):(edge_weight)}
        
        
        Braess Adjacency Matrix
        ------The graph after the braess paradox has occured., The graph is store as a dictionary. 
        -----(The graph is store as a dictionary, Dict->{(edge):(edge_weight)}
        
        Amount of Traffic
        ------Amount of Bots involed in it. 
        -----(Data in this column is a integer)
        
        Initial Average Travel Time
        ------Average travel time of the graph before the braess paradox has occurred. 
        -----(Data in this column is a floating number)
        
        Braess Average Travel Time
        ------Average travel time of the graph after the braess paradox has occurred.
        -----(Data in this column is a floating number.)
        
        Graph Spectrum
        ------Contains all the graphs in the spectrum involved in the simulation.
         -----The data in this column is a numpy array of all the graphs, where
         ----(The graph is store as a dictionary, Dict->{(edge):(edge_weight)})
        
        Travel Time Associated with it.
        ------Every Graph has an average travel time. 
        -----(The data in this column is stored as a list of integer)
        
        """)



    #Test code----------------------------TEST CODES AND FUNCTIONS
    def testing_if_data_stored_correctly(self, data_str):
        print(self.columns_names[0], data_str[self.columns_names[0]])
        print(self.columns_names[1], data_str[self.columns_names[1]])
        print(self.columns_names[2], data_str[self.columns_names[2]])
        print(self.columns_names[3], data_str[self.columns_names[3]])
        print(self.columns_names[4], data_str[self.columns_names[4]])
        print(self.columns_names[5], len(data_str[self.columns_names[5]]))
        print(self.columns_names[6], len(data_str[self.columns_names[6]]))
        print(self.columns_names[7], data_str[self.columns_names[7]])
        return None


    def testing(self):
        data = {"K": [1, 3], "L": [23, 23]}
        df = pd.DataFrame(data)
        df = df.to_csv("t.csv", mode='a', index=False, header=True)
        new_data = {"K": [23], "L": [90]}
        existing_df = "t.csv"
        existing_df = pd.read_csv("t.csv")
        new_df = pd.DataFrame(new_data)
        updated_df = existing_df.append(new_df, ignore_index=False)
        updated_df.to_csv("t.csv", index=False)

        #Testing code to see if it still works as existing df keeps file open
        new_data1 = {"K": [23121], "L": [123132]}
        new_df1 = pd.DataFrame(new_data1)
        updated_df = existing_df.append(new_df1, ignore_index=False)
        updated_df.to_csv("t.csv", index=False)





















